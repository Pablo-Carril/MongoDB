<div class="Editor">

  <h4>Editar registro: </h4>
  <div>
    {{>formulario ocultar=true}}
    <!--podemos enviar datos al llamar a parciales (ocultar es para ocultar el boton guardar y consultar)-->
  </div>
  <!--una vez ocultados agregamos borar, actualizar, y cancelar-->
  <div class="botones">
    <button id="borrar" class="btn btn-danger text-white ms-4">Borrar</button>
    <button id="actualizar" class="btn btn-info text-white ms-4">Actualizar</button>
    <a href="/api/equipos/{{serie}}" class="btn btn-primary text-white ms-4">Cancelar</a>
  </div>

  {{>popup}}

</div>

<script>
  const formulario = document.getElementById('formEntrada')
  borrar = document.getElementById('borrar')

  borrar.addEventListener('click', () => {
    mostrarPopup()    //pedimos confirmación para borrar
  })

  function confirmarBorrado() {
    fetch('/api/equipos/delete/{{id}}', {    //siempre tiene que comenzar con la raíz (/) y TODA la ruta. con fetch no se pueden acortar las rutas como en los routers.
      method: 'DELETE',                         //porque estamos del lado del cliente
      headers: {
        'Content-Type': 'application/json',
        // Puedes agregar más encabezados si es necesario
      },
      body: JSON.stringify({ id: '{{id}}', serie: {{ serie }} }), //ENTONCES ES POSIBLE LEER VARIABLES DE HBS EN JAVASCRPT!!!
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`Error de red - ${response.status}`);
        }
        return response.json();  // Si esperas una respuesta JSON. el return es necesario para procesar el siguiente then.
      })
    .then(msg => {
      console.log('Se eliminó el ID: {{id}}', msg)
      window.location.href = `/api/equipos/{{serie}}`;    // volvemos a ese serie
      history.replaceState({}, '', `/api/equipos/{{serie}}`);  //evitamos que vuelva al formulario al retroceder la página. tienen que estar las dos líneas.
    })  //muestro el mensaje en la consola del cliente
    .catch((error) => { console.log('Ocurrió un error: ', error) })
    }

  actualizar = document.getElementById('actualizar')
  actualizar.addEventListener('click', () => {
    //Leer Los datos actualizados:
    const datosForm = new FormData(formulario)         //se pasa el OBJETO formulario
    const datosJSON = JSON.stringify(Object.fromEntries(datosForm.entries()));   // PRUEBO mejor como JSON
    fetch('/api/equipos/actualizar/{{id}}', {
      method: 'PUT',          //exite otra forma de enviar el formulario datosForm sin pasar a Json, pero no pude hacer que el servidor lo lea.
      headers: {
        'Content-Type': 'application/json',   //sin esto no anda.
      },
      //Enviamos los DATOS por el BODY para probar. funciona bien como Json.
      body: datosJSON  //otra forma es con body: JSON.stringify({ y todos los datos individuales con doble llaves de handlebars.
    })
      .then(response => {
        if (!response.ok) {
          throw new Error(`Error de red - ${response.status}`);
        }
        return response.json();
      })
      .then(msg => {
        console.log('Se actualizó el ID: {{id}}', msg)
        window.location.href = `/api/equipos/{{serie}}`;    // volvemos a ese serie
        // while (history.length > 1) {  //NO FUNCIONA SE QUEDA PENSANDO...
        //   history.back();  //borramos todo el historial anterior de la pestaña.
        // }
        history.replaceState({}, '', `/api/equipos/{{serie}}`);
      })  //muestro el mensaje en la consola del cliente

      .catch(err => { console.log('Ocurrió un error: ', err) })
  })

// CUIDADO: HANDLEBARS también reemplaza las variables dentro de los COMENTARIOS, y puede traer problemas
// al llegar un dato con errores o inclusive un Enter en un string, y hace fallar el script en el NAVEGADOR.
  
</script>

<style>
  .Editor {
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #formEntrada {
    min-width: 500px;
  }

  .botones {
    min-width: 500px;
    display: flex;
    justify-content: space-around;
  }
</style>